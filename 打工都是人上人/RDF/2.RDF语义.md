# RDF语义

[toc]

## 1. 简介

该文档定义了RDF图以及RDF和RDFS词汇表的模型理论语义，提供了有关何时通过RDF转换或从其他RDF派生RDF内容的操作来保存真相的确切形式规范。

## 2. 一致性

除了标记为非规范的部分，本规范中的所有创作指南、图表、示例和注释都是非规范的。本规范中的其他内容都是规范的。

本规范中的关键字must、must not、required、should、should not、recommended、may和optional的解释见[RFC2119]。

这说明，RDF 1.1语义，是RDF语义和RDF推理过程有效性的规范。对于RDF含义的许多方面，它不是标准的，这些方面没有被这个语义描述或指定，包括使用中如何赋予IRIs含义的社会问题，以及IRIs的指示物如何与在其他媒体(如自然语言文本)中表示的Web内容相关联。

## 3. 语义扩展和蕴含机制

RDF旨在用作各种扩展符号的基础符号，例如OWL [ [OWL2-OVERVIEW](https://www.w3.org/TR/rdf11-mt/#bib-OWL2-OVERVIEW) ]和RIF [ [RIF-OVERVIEW](https://www.w3.org/TR/rdf11-mt/#bib-RIF-OVERVIEW) ]，它们的表达式可以编码为RDF图，该图使用具有特殊定义含义的特定词汇表。同样，特定的IRI词汇可以通过其他规范或约定来赋予含义。如果假设了这些额外的含义，则给定的RDF图可能支持比基本RDF语义所批准的范围更大的扩展。通常，在RDF图中对IRI的含义所作的假设越多，则从这些假设中得出的结论就越多。

这样的一组特定的语义假设称为语义扩展。每个[语义扩展都](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)定义了在该扩展名下有效的[蕴含机制](https://www.w3.org/TR/rdf11-mt/#bib-SPARQL11-ENTAILMENT)（此处使用的蕴含机制与SPARQL 1.1蕴含机制建议[ [SPARQL11-ENTAILMENT](https://www.w3.org/TR/rdf11-mt/#bib-SPARQL11-ENTAILMENT) ]相同）。RDFS（在本文档的后面部分进行介绍）就是这样一种[语义扩展](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)。我们将通过诸如*RDFS蕴含*，*D蕴含*等名称来指代蕴含机制。

[语义扩展](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)*可能*会对RDF图施加特殊的语法条件或限制，例如要求出现某些三元组，或禁止三元组中IRIs的特定组合，并且*可能*会认为不符合这些条件的RDF图是错误的。例如，

```
ex:a rdfs:subClassOf "Thing"^^xsd:string .
```

在基于描述逻辑[ [OWL2-SYNTAX](https://www.w3.org/TR/rdf11-mt/#bib-OWL2-SYNTAX) ]的OWL[语义扩展](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)中禁止该形式的RDF语句。在这种情况下，基本的RDF操作（例如获取三元组的子集或组合RDF图）可能会在解析器中引起语法错误，这些解析器会识别扩展条件。本文档中规范定义的[语义扩展](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)都没有对RDF图施加这样的语法限制。

所有蕴含机制都*必须*是文档中描述的简单蕴涵机制的单调扩展，在某种意义上，如果A简单的[包含](https://www.w3.org/TR/rdf11-mt/#dfn-entail)B，则A在任何扩展的包含概念下也包含B，前提是扩展的任何语法条件也得到满足。换句话说，[语义扩展](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)不能“取消”由较弱的蕴涵机制产生的蕴涵，尽管它可以将结果视为语法错误。

## 4. 符号和术语

本文档使用以下术语描述RDF图语法，所有术语均在随附的RDF概念规范[ [RDF11-CONCEPTS](https://www.w3.org/TR/rdf11-mt/#bib-RDF11-CONCEPTS) ]中定义：*[IRI](http://www.w3.org/TR/rdf11-concepts/#dfn-iri)*，*[RDF三元](http://www.w3.org/TR/rdf11-concepts/#section-triples)，[RDF图](http://www.w3.org/TR/rdf11-concepts/#section-rdf-graph)，[主题](http://www.w3.org/TR/rdf11-concepts/#section-triples)，[谓词](http://www.w3.org/TR/rdf11-concepts/#section-triples)，[对象](http://www.w3.org/TR/rdf11-concepts/#section-triples)，[RDF源](http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-source)，[节点](http://www.w3.org/TR/rdf11-concepts/#dfn-node)，[空白节点](http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node)，[文字](http://www.w3.org/TR/rdf11-concepts/#dfn-literal)，[同构](http://www.w3.org/TR/rdf11-concepts/#graph-isomorphism)和[RDF数据集](http://www.w3.org/TR/rdf11-concepts/#section-dataset)。*本文档中的所有定义均不变地适用于[广义RDF三元组，图形和数据集](http://www.w3.org/TR/rdf11-concepts/#section-generalized-rdf)。

一种解释是从IRIs和文字到集合的映射，以及集合和映射上的一些约束。本文档定义了各种解释概念，每一个概念都以一种标准的方式对应于一种蕴涵制度。它们由前缀（如*简单解释（*simple interpretation*）*等）标识，并在后面的章节中定义。非限定术语*解释*一词通常是指一般意义上的任何一种兼容的解释，但如果上下文清楚，则可能指某一种特定的解释。

*denotes*和*refers to*在IRI或文字与它在给定解释中所指的内容之间的关系时通常作为同义词互换使用，被称作*denotation*或*referent*。IRI的含义也可能由RDF语义之外的其他约束决定;当我们希望引用这种外部定义的命名关系时，我们将使用**identify（标识）**这个词及其同源词。例如，IRI`http://www.w3.org/2001/XMLSchema#decimal`被广泛用作XML Schema文档[ [XMLSCHEMA11-2](https://www.w3.org/TR/rdf11-mt/#bib-XMLSCHEMA11-2) ]中描述的数据类型的名称，这一事实可以这样描述：IRI*identifies（标识）*该数据类型。如果IRI标识出某物，则在给定解释中它可能会或可能不会引用它，具体取决于如何指定语义。例如，用于[标识](https://www.w3.org/TR/rdf11-mt/#dfn-identify)[RDF数据集中](http://www.w3.org/TR/rdf11-concepts/#section-dataset)中已命名图的图名的IRI可能指的是与其标识的图不同的东西。

在整个文档中，等号=表示严格的身份。语句“ A = B”意味着有一个实体，表达式“A”和“B”都指向它。尖括号<x，y>用于指示x和y的有序对。

在整个文档中，[RDF图](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-graph)和RDF抽象语法的其他片段都是使用Turtle语法[ [TURTLE](https://www.w3.org/TR/rdf11-mt/#bib-TURTLE) ]的符号约定编写的。名称空间前缀`rdf:` `rdfs:`和`xsd:`在[ [RDF11-CONCEPTS](https://www.w3.org/TR/rdf11-mt/#bib-RDF11-CONCEPTS) ]中的[1.4节](http://www.w3.org/TR/rdf11-concepts/#vocabularies)使用。当IRI不重要时，则使用`ex:`前缀。在陈述一般规则或条件时，我们使用三个字符的变量（例如aaa，xxx，sss）来指示任意IRIs，文字或RDF语法的其他组件。在某些情况下，用“节点-边”图直接显示图形结构。

**name（名称）**代表任何IRI或文字。带类型的文字包含两个**name**：文字本身和文字类型IRI。词汇表是 [name](https://www.w3.org/TR/rdf11-mt/#dfn-name)s的集合

**empty graph（空图）**是空三元组的集合。

RDF图的**subgraph（子图）**是图中三元组的子集。三元组可以看做只包含一个三元组的集合，因此图中的每个三元组都被认为是一个子图。**proper subgraph（真子图）**是图中三元组的真子集。

**ground（基础）**RDF图指的是不包含空节点的RDF图。

假设M是从一组 空白节点到一组文字，空白节点和IRI的功能映射。任何用M（N）代替G中的部分或全部空白节点N而得到的图都是G的一个**instance**（实例）。任何图都是它自身的一个实例，G的一个实例的一个实例也是G的一个实例，如果H是G的一个实例，那么H中的每个三元组都是G中至少一个三元组的一个实例。

**instance with respect to（实例相关于）**词汇表V是这样一个[实例](https://www.w3.org/TR/rdf11-mt/#dfn-instance)：在该实例中，所有被替换为原始空白节点的 [name](https://www.w3.org/TR/rdf11-mt/#dfn-name)s（名称）都来自词汇表V中的 [name](https://www.w3.org/TR/rdf11-mt/#dfn-name)s（名称）。

图的**proper instance（适当实例、真实例）**是这样的[实例](https://www.w3.org/TR/rdf11-mt/#dfn-instance)，其中空白节点已被[name(名称)](https://www.w3.org/TR/rdf11-mt/#dfn-name)替换，或者图中的两个空白节点已映射到实例中的同一节点。

当两个图通过空白节点上的1：1映射相互映射时，它们是[isomorphic（同构）](http://www.w3.org/TR/rdf11-concepts/#graph-isomorphism)的。同构图是具有可逆实例映射的相互实例。由于空白节点除了在图形中的位置外没有其他特定的标识，因此我们经常将同构图形视为相同。

一个RDF图如果没有实例作为其自身的真子图。那么它就是**lean（精简）**的。非精简图具有内部冗余，并表达与它们的精益子图相同的内容。例如，图表

```
ex:a ex:p _:x .
_:y ex:p _:x .
```

是非精简的，但是

```
ex:a ex:p _:x .
_:x ex:p _:x .
```

是精简的，**ground（基础）**RDF图是精简的。

### 4.1 共享的空白节点，联合和合并

图只有在其从由文档或其他结构（例如RDF数据集）描述的图派生而来时才共享空白节点，这些文件或其他结构明确规定了在不同RDF图之间共享空白节点。仅仅下载Web文档并不意味着结果RDF图中的空白节点与来自同一文档的其他下载或相同[RDF源](http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-source)的空白节点相同。

处理使用空白节点标识符的RDF的具体语法的RDF应用程序应注意跟踪它们标识的空白节点的身份。空白节点标识符通常具有局部作用域，因此，当组合来自不同来源的RDF时，可能必须更改标识符，以避免不同空白节点的意外合并。

例如，两个文档都可以使用空白节点标识符“ `_:x`”来标识空白节点，但是除非这些文档在共享标识符范围内或从公共来源派生，否则`_:x`在一个文档中出现“ ”将标识一个不同的节点。空白节点，而不是其他文档描述的图中的节点。当通过组合来自多个来源的RDF来形成图时，可能有必要通过使用其他文档中未出现的空白节点标识符替换（现有的）空白节点标识符来**standardize（标准化）**空白节点标识符。例如，以下文本代表两个图形：

```
ex:a ex:p _:x .
```

![图1](https://www.w3.org/TR/rdf11-mt/RDF11SemanticsDiagrams/example1.jpg)

```
ex:b ex:q _:x .
```

![图2](https://www.w3.org/TR/rdf11-mt/RDF11SemanticsDiagrams/example2.jpg)

包含四个节点。因此，它们的联合还将包含四个节点：

![联合图](https://www.w3.org/TR/rdf11-mt/RDF11SemanticsDiagrams/example4.jpg)

但是，通过简单地串联以下文本表面表示而形成的文档：

```
ex:a ex:p _:x .
ex:b ex:q _:x .
```

描述了一个包含三个节点的图：

![联合图不正确](https://www.w3.org/TR/rdf11-mt/RDF11SemanticsDiagrams/example3.jpg)

因为在公共标识符范围内出现的两个空白节点标识符`_:x`标识同一个空白节点。这两个图的四节点并集可以用下面的形式更恰当地描述，例如：

```
ex:a ex:p _:x1 .
ex:b ex:q _:x2 .
```

其中空白节点标识符已经[标准化](https://www.w3.org/TR/rdf11-mt/#dfn-standardize)，以避免混淆不同的空白节点。（使用的特定空白节点标识符没有意义，只是它们是不同的。）

两个或更多图形可能共享一个空白节点，例如，如果它们是单个较大图形的子图形或从公共源派生。在这种情况下，一组图的并集保留了图之间共享的空白节点的标识。通常，RDF图集的并集准确地表示与图本身相同的语义内容，无论它们是否共享空白节点。

一个称为**merging（合并）**的操作，强制任何在多个图中出现的共享空节点在每个图中都是不同的之后进行合并。生成的图称为合并。一个图的子图的合并可能比原始图大。例如，合并三节点图的两个单例子图的结果

![三节点图](https://www.w3.org/TR/rdf11-mt/RDF11SemanticsDiagrams/example3.jpg)

是四节点图

![四节点图](https://www.w3.org/TR/rdf11-mt/RDF11SemanticsDiagrams/example4.jpg)

联合始终是合并的一个实例。如果图没有共同的空白节点，则它们的合并和联合是相同的。

## 5. 简单的解释

本部分定义了RDF图的简单解释和真实性的基本概念。在RDF中编码的任何词汇表或更高阶符号的所有[语义扩展](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)都*必须*符合这些最小真实条件。其他[语义扩展](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)可扩展它们同时向它们添加信息，但他们*不得*修改或否定他们。例如，因为简单的解释是适用于IRI的映射，所以[语义扩展](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)不能以不同的方式解释单个IRI的不同出现。

整个语义适用于[RDF图](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-graph)，而不适用于[RDF源](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-source)。[RDF源](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-source)只有通过在给定时间或给定状态下的图才具有语义。图不能随时间改变其语义。

一个简单的解释“I”是一个结构，包括：

```
非空资源集IR，称为I的域或空间。
IP集合，称为I的属性集。
从IP到{IR x IR}的幂集的映射IEXT，即IR中具有x和y的一组对<x，y>的集合。
从IR到{IR ∪ IP}的映射IS
从文字到IR的部分映射IL
```
>**Change Note**
>
>2004 RDF 1.0语义定义了相对于词汇的简单解释。
>
>在2004 RDF 1.0语义中，IL是全部而不是部分映射。
>
>2004 RDF 1.0规范将文字分为不带类型和可选语言标签的“普通”文字，以及带类型的文字。用法表明，每个文字都必须有一个类型，这一点很重要。RDF 1.1用XML Schema`string`数据类型键入的文字替换了没有语言标签的普通文字，并[`rdf:langString`](http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string)为语言标记的字符串引入了特殊类型。下一节将提供类型文字的完整语义。

>**Note**
>
>所有的[names(名称)](https://www.w3.org/TR/rdf11-mt/#dfn-name)都需要简单的解释，因此是无限的。这简化了阐述。然而，RDF可以使用有限的结构、可确定的算法来解释。详情载于附录B。

IEXT(x)，称为x的**extension（扩展）**，是一组对，用于标识属性为true的参数，即二进制关系扩展。

当定义数据类型的语义时，IR和IL之间的区别将变得很重要。由于部分文字可能无法包含参照物，因此IL可以是局部的。

>**Note**
>
>通常将关系名称直接映射到关系扩展。但是，这假定词汇表被分为关系名称和个人名称，RDF不做这样的假设。此外，RDF允许将IRI用作关系名称，并将其用作自变量。例如，在RDFS中使用了这种自我应用程序结构。使用IEXT映射将关系作为对象从其关系扩展中区分出来可同时满足这两个要求。它还提供了RDFS“类”的概念，可以将其与集合理论的扩展区分开。ISO / IEC通用逻辑标准[ [ISO24707](https://www.w3.org/TR/rdf11-mt/#bib-ISO24707) ]中使用了类似的技术。

然后，由以下规则给出在简单解释I中对**ground（基础）**RDF图的表示，其中，该解释也被视为从表达式（名称，三元组和图形）到空间元素和真值的函数：

| 如果E是文字，则I(E)= IL(E)                                   |
| ------------------------------------------------------------ |
| 如果E是IRI，则I(E)= IS(E)                                    |
| 如果E是**ground（基础）**三元组<s,p,o>， 则当I(p)在IP中，而对<I(s)，I(o)>在IEXT(I(p))中时，I(E)= true。否则，I(E)=false。 |
| 如果E是**ground（基础）**RDF图，则对于E中的某些三元组E'，如果I(E')= false，则I(E)= false，否则I(E)= true。 |

如果未为某些文字E定义IL(E)，则E没有语义值，因此包含它的任何三元组将为false，因此包含该三元组的任何图也将为false。

最终条件意味着空图（三元组的空集）始终为真。

IP和IR的集合可能重叠，实际上IP可能是IR的子集。由于IEXT上的域条件，任何真实三元组的主语和宾语的表示将在IR中；因此，在图表中既作为谓词又作为主语或宾语出现的任何IRI都将表示IP与IR的交集。

[语义扩展](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)可以通过要求某些IRI以特定方式进行引用来对解释映射施加其他约束。例如，如下所述的**D-interpretations（D解释）**要求某些IRI具有固定的符号，这些IRI被理解为[identifying(识别)](https://www.w3.org/TR/rdf11-mt/#dfn-identify)和引用数据类型。

### 5.1 空白节点

空白节点被视为简单地指示事物的存在，而无需使用IRI来 [identify(识别)](https://www.w3.org/TR/rdf11-mt/#dfn-identify)任何特定事物。这与假设空白节点指示“未知” IRI不同。

假设“I”是一个简单的解释，A是从一组空白节点到I的空间IR的映射。将映射[I + A]定义为在[names(名称)](https://www.w3.org/TR/rdf11-mt/#dfn-name)上为I、在空白节点上的A：当x是[name(名称)](https://www.w3.org/TR/rdf11-mt/#dfn-name)时，\[I+ A](x)= I(x)；当x是空白节点时，\[I + A](x)= A(x)；并使用上面针对**ground（基础）**图给出的规则将此映射扩展到三元组图和RDF图。然后，RDF图的语义条件为：

```
如果E是RDF图，则对于从E中的空白节点集到IR的某些映射A，如果[I + A](E)= true，则I(E)= true，否则I(E)= false。
```

从空白节点到引用对象的映射不是简单解释的定义的一部分，因为真实条件仅涉及*某些*此类映射。空白节点本身与其他节点的不同之处在于，没有通过简单的解释为其分配符号，这反映了直觉，即它们没有“全局”含义。

#### 5.1.1 共享的空白节点（信息性）

*本节是非规范性的。*

空白节点的语义是根据图的真实性来陈述的。但是，当两个（或多个）图共享一个空白节点时，通过单独处理它们并不能完全理解它们的含义。例如，考虑重叠图

![重叠图](https://www.w3.org/TR/rdf11-mt/RDF11SemanticsDiagrams/example5.jpg)

和一个空间为{Alice，Bob，Monica，Ruth}的简单解释“I”，其中：

I（`ex:Alice`）= Alice，I（`ex:Bob`）= Bob，IEXT（I（`ex:hasChild`））= {<Alice，Monica>，<Bob，Ruth> }

在这种解释下，每个内部图都是正确的，但两个图一起观察时却不是正确的，因为三节点图表示爱丽丝和鲍勃在一起生了一个孩子。为了捕获共享一个空白节点的图的全部含义，有必要考虑包含所有包含该空白节点的三元组的并集图。

>**Note**
>
>RDF图可以看作是一阶逻辑中简单原子语句的结合，其中空白节点是自由变量，被认为是存在的。然后，将两个图进行并集就类似于此语法中的语法合取。RDF语法没有显式的变量绑定量词，因此任何RDF图的真实条件都会将该图中的自由变量视为该图中存在的量化值。选取共享空白节点的图的并集会更改隐含的量词范围。

### 5.2 简单蕴含

按照标准术语，我们说当I(E)= true时，I(简单的)**satisfies(满足)**E；当存在满足它的简单解释时，E(简单地)可**satisfies(满足)**；否则(简单地)不**satisfies(满足)**。图G**entails(蕴含)**图E当每一个解释在满足图G时也满足图E。如果两个图E和F各自蕴含另一个，那么它们在逻辑上是**equivalent（等价）**的。

在后面的部分中，这些概念将适用于其他类别的解释，但是在本节中，“蕴含”应始终解释为简单蕴含。

> **Note**
>
> 我们没有定义图集之间的蕴涵的概念。为了确定一组图形是否蕴含另一个图形，必须首先通过采用图形的并集或合并将一组图形组合成一个图形。并集保留共享空白节点的通用含义，而合并则有效地忽略了空白节点的任何共享。合并图集会产生与2004 RDF 1.0规范中定义的集相同的定义。

如果S在任何情况下都简单地蕴含了E，则任何从其他图S构造图E的过程都是(简单地)**valid(有效)**的；否则**invalid(无效)**。

推理是有效的这一事实不应该被理解为任何RDF应用程序都有义务或需要进行推理。类似地，某些RDF转换或流程的逻辑无效并不意味着该流程不正确或被禁止。该规范中没有要求或禁止对RDF图或源进行任何特定的操作。蕴涵和有效性只涉及在这样的操作上建立条件，以保证真理的保存。虽然不禁止逻辑上无效的流程(不遵循有效的蕴涵)，但用户应该意识到，他们可能面临将错误引入真实RDF数据的风险。然而，在可以通过其他手段确保真相的情况下，对逻辑无效过程的特殊使用可能是合理的，并适合于数据处理。

蕴涵仅指RDF图的真实性，而不涉及它们对任何其他用途的适用性。RDF图可能适合于给定的目的，但同时又需要另一个不适合同一目的图。一个示例是RDF测试用例清单[ [RDF-TESTCASES](https://www.w3.org/TR/rdf11-mt/#bib-RDF-TESTCASES) ]，它作为RDF文档提供，以方便用户使用。本文档通过描述前因后果和结论，列出了正确蕴含的示例。作为一个RDF图，清单只是蕴含了一个省略了先行词的子图，因此，如果用作测试用例清单，则是不正确的。这并没有违反RDF语义规则，但是它表明了“作为一个正确的RDF测试用例清单”的属性没有被保留在RDF限定下，因此不能被描述为[RDF语义扩展](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)。应该将此类隐含风险的RDF使用限制在以下情况中:与使用RDF在Web上公开发布数据的更正常的情况相反，在这里，各方都清楚地知道隐含的特殊限制是什么。

### 5.3 简单蕴含的属性（资料性）

*本节是非规范性的。*

此处描述的属性仅适用于简单蕴含，不适用于后面几节中引入的扩展蕴含概念。证明在附录C中给出。

> 每个图都是可以满足的。

这并不总是适用于解释的扩展概念。例如，包含[错误类型](https://www.w3.org/TR/rdf11-mt/#dfn-ill-typed)文字的图是[D-unsatisfiable](https://www.w3.org/TR/rdf11-mt/#dfn-d-unsatisfiable)。

以下**interpolation lemma（插值引理）**

> 当且仅当G的子图是E的实例时，G才简单地蕴含图E。

利用语法描述简单蕴含的内容：要检测一个RDF图是否蕴含另一个图，请检查被蕴含的图是否存在某些实例，该实例是第一个图的子集。

>**Note**
>
>这显然是可以决定的，但是通常也很难确定，因为可以将NP-硬子图问题（检测一个数学图是否是另一个数学图的子图）编码为检测RDF图之间的简单蕴涵。这种构造（Jeremy Carroll提出）使用了所有节点均为空白节点的图。结论E中的空白节点更少，从而减少了检查简单蕴含的复杂性。当E是[ground（基础）](https://www.w3.org/TR/rdf11-mt/#dfn-ground)图时，只需检查三元组上的子集关系即可。

[插值](https://www.w3.org/TR/rdf11-mt/#dfn-interpolation)有许多直接结论，例如：

> [empty graph（空图）简单蕴含于任何图形，并且除了它自己不简单蕴含任何图

> 一个图简单蕴含其所有子图。

> 一个图蕴含于所有它的 [instance（实例）](https://www.w3.org/TR/rdf11-mt/#dfn-instance)。

> 如果E是一个[lean（精简）](https://www.w3.org/TR/rdf11-mt/#dfn-lean)图，而E'是E的一个[proper instance（适当实例）](https://www.w3.org/TR/rdf11-mt/#dfn-proper-instance)，那么E不会简单蕴含E'。

> 如果S是S'的子图，并且S简单E，则S'简单蕴含E。

> 如果S简单有限图E，则S的某个有限子集S'简单蕴含E。

上面的属性称为*compactness（简洁）*-RDF是简洁的的。由于RDF图可以是无限的，所以有时这很重要。

> 如果E包含在S的任何地方都不会出现的IRI，则S不会简单蕴含E。

## 6. Skolemization（信息性）

*本节是非规范性的。*

[Skolemization](https://www.w3.org/TR/rdf11-mt/#dfn-skolemization)是RDF图上的一种转换，它通过将空白节点替换为“新” IRI来消除空白节点，这意味着为此目的而创造的IRI因此得以保证（在创建时）不会出现在任何其他RDF图中。请参阅[[ RDF11-CONCEPTS](https://www.w3.org/TR/rdf11-mt/#bib-RDF11-CONCEPTS) ]的[3.5节](http://www.w3.org/TR/rdf11-concepts/#section-skolemization)，以进行更全面的讨论。

假设G是一个包含空白节点的图，并且sk是从G中的空白节点到替代它们的skolem IRI的简化映射，因此sk（G）是G的简化，那么它们之间的语义关系可以是总结如下。

> sk（G）简单蕴含G（因为sk（G）是G的一个实例。）

> G并不简单蕴含sk（G）（因为sk（G）存在不在G中的IRI）。

> 对于任何图H，如果sk（G）简单蕴含H，则存在图H'，使得G简单蕴含H'且H = sk（H'）。

> 对于任意不包含引入sk（G）的任何“新” IRI的图H，当且仅当G简单蕴含H时，sk（G）简单蕴含H。

第二个属性表示图在逻辑上不[equivalent等效](https://www.w3.org/TR/rdf11-mt/#dfn-equivalent)使其成为臭名昭著。但是，从强烈的意义上讲，它们几乎可以互换，如以下两个属性所示。第三个属性意味着，即使从包含新词汇表的skolemized图中得出结论，这些结论也将准确地反映出在原始空白节点的位置上从原始图派生出的内容。用IRIs替换空白节点除了给以前的匿名实体提供新的名称之外并不能有效地改变从图形中导出的有效地内容。第四个属性是第三个属性的结果，它清楚地表明，从某种意义上说，就所涉及的问题而言，G的简化可以“代表”G。使用sk（G）代替G不会影响任何不涉及新skolem词汇的附带条件。

## 7. 文字和数据类型

> **Change Note**
>
> 在2004 RDF 1.0规范中，数据类型D-entailment被定义为RDFS-entailment的[语义扩展](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)。在这里，它被定义为基本RDF的直接扩展。这更符合实际用法，在这种用法中，带有数据类型的RDF被广泛使用而没有RDFS词汇。如果有必要将其与2004 RDF 1.0术语区分开，则应使用更长的措词“简单D蕴含”或“简单数据类型蕴含”，而不是“ D蕴含”。

数据类型由IRI[identified（标识）](https://www.w3.org/TR/rdf11-mt/#dfn-identify)。根据IRI被识别为表示数据类型的不同，解释会有所不同。我们在简单的解释中使用参数D对此进行描述，其中D是可**recognize（识别）**的数据类型IRI的集合。

>**Change Note**
>
>该规范的先前版本将参数D定义为从IRI到数据类型的[数据类型映射](https://www.w3.org/TR/rdf11-mt/#dfn-datatype-map)，即作为一种受限的解释映射。由于当前语义假定公认的IRI标识唯一的数据类型，因此IRI到数据类型的映射是全局唯一的并在外部指定，因此我们可以将D视为一组IRI或固定的[数据类型映射](https://www.w3.org/TR/rdf11-mt/#dfn-datatype-map)。形式上，与集合D对应的**数据类型映射**是[D解释](https://www.w3.org/TR/rdf11-mt/#dfn-d-interpretation)对集合D的限制。根据[数据类型映射](https://www.w3.org/TR/rdf11-mt/#dfn-datatype-map)的条件陈述的语义扩展可以解释为适用于此映射。 

IRI[identifies（识别）](https://www.w3.org/TR/rdf11-mt/#dfn-identify)数据类型的确切机制被认为是语义外部的，但是语义假定已识别的IRI[identifies（标志）](https://www.w3.org/TR/rdf11-mt/#dfn-identify)唯一的数据类型，无论它在哪里出现。不能确定由IRI标识的数据类型的RDF处理器也不能识别该IRI，应该将任何具有IRI是数据类型IRI的文字视为未知名称。

[ [RDF11-CONCEPTS](https://www.w3.org/TR/rdf11-mt/#bib-RDF11-CONCEPTS) ]的[第5节](http://www.w3.org/TR/rdf11-concepts/#section-Datatypes)中全面描述了RDF文字和数据类型。总结：除了一个例外，RDF文字将字符串和[identifies（标识）](https://www.w3.org/TR/rdf11-mt/#dfn-identify)数据类型的IRI结合在一起。带[语言标记的字符串](http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string)是一个例外，它具有两个语法组成部分：字符串和语言标记，并被分配了`rdf:langString`类型。数据类型应理解为定义从词法空间（一组字符串）到值的部分映射，称为**lexical-to-value mapping（词法到值映射）**。L2V函数将数据类型映射到它们的词法到值映射。数据类型为d的文字表示通过将此映射应用于字符串sss获得的值：L2V(d)(sss)。如果文字字符串不在词法空间中，那么从词法到值的映射就不会为文字字符串提供任何值，那么该文字就没有引用对象。数据类型的值空间是[lexical-to-value mapping（词法到值映射）](https://www.w3.org/TR/rdf11-mt/#dfn-lexical-to-value-mapping)的范围。每个具有该类型的文字要么引用该类型的值空间中的一个值，要么根本无法引用。一个**ill-typed（错误类型）**的文字其数据类型IRI被[recognize（识别）](https://www.w3.org/TR/rdf11-mt/#dfn-recognize)，但该数据类型的[lexical-to-value mapping（词法到值映射）](https://www.w3.org/TR/rdf11-mt/#dfn-lexical-to-value-mapping)没有为其字符串赋值。

RDF处理器不需要[recognize（识别）](https://www.w3.org/TR/rdf11-mt/#dfn-recognize)[`rdf:langString`](http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string)和[`xsd:string`](http://www.w3.org/TR/xmlschema11-2/#string)之外的任何数据类型的IRIs，但是，当[RDF11-CONCEPTS](https://www.w3.org/TR/rdf11-mt/#bib-RDF11-CONCEPTS)[第5节](http://www.w3.org/TR/rdf11-concepts/#section-Datatypes) 中列出的IRIs被识别时，它们必须按照描述进行解释，当识别IRI rdf: plain - literal时，必须将其解释为引用[ [RDF-PLAIN-LITERAL](https://www.w3.org/TR/rdf11-mt/#bib-RDF-PLAIN-LITERAL) ]中定义的数据类型。RDF处理器*may(可以)*识别其他数据类型IRIs，但是当识别其他数据类型IRIs时，*must(必须)*明确指定数据类型IRI和它所引用的数据类型之间的映射，并且*must(必须)*在所有RDF转换或操作期间固定。实际上，这可以通过将IRI链接到数据类型的外部规范来实现，该规范既描述了数据类型本身的组成部分，也描述了IRI标识数据类型的事实，从而固定了该IRI的[数据类型映射](https://www.w3.org/TR/rdf11-mt/#dfn-datatype-map)的值。

以[`rdf:langString`作为文字的数据类型是一种例外情况，将对其进行特殊处理。IRI`rdf:langString`被分类为数据类型IRI，并且即使未为其定义L2V映射，也将其解释为引用数据类型。 `rdf:langString`的值空间是带有语言标签的所有字符串对的集合。下面给出了以其为类型的文字的语义。

RDF文字语法允许在类型文字中使用任何IRI，即使它没有被[recognize（识别）](https://www.w3.org/TR/rdf11-mt/#dfn-recognize)为引用数据类型。具有这种“未知”数据类型IRI(不属于可[recognize（识别）的数据类型集)的文字，尽管RDF应用程序*may(可以)*发出警告，但*should(不应)*将其视为错误。这样的文字should(*应该)*像IRI一样对待，并假定表示空间IR中的某些事物。不识别数据类型IRI的RDF处理器将无法检测到对识别数据类型的处理器可见的一些蕴涵机制。例如，事实是

```
ex:a ex:p "20.0000"^^xsd:decimal .
```

蕴含

```
ex:a ex:p "20.0"^^xsd:decimal .
```

对于不能[recognize（识别）`xsd:decimal`](https://www.w3.org/TR/rdf11-mt/#dfn-recognize)数据类型IRI的处理器将不可见。

### 7.1 D-interpretations

令D为一组IRI[identifies（标志）](https://www.w3.org/TR/rdf11-mt/#dfn-identify)数据类型。**(simple)D-interpretation（简单 D-解释）** 是一个[simple interpretation(简单解释)](https://www.w3.org/TR/rdf11-mt/#dfn-simple-interpretation) ，其满足以下条件：

| 如果`rdf:langString`在D中，则对于具有词法形式sss和语言标签ttt的每个带有语言标签的字符串E，IL(E)= <sss，ttt'>，其中ttt'为ttt使用US-ASCII规则转换为小写 |
| ------------------------------------------------------------ |
| 对于D中的每个其他IRI aaa，I(aaa)是由aaa标识的数据类型，对于每个文字“ sss” ^^ aaa，IL(“ sss” ^^ aaa)= L2V(I(aaa))(sss) |

如果文字 [ill-typed（错误类型）](https://www.w3.org/TR/rdf11-mt/#dfn-ill-typed)则L2V(I(aaa))映射将没有值，因此文字无法表示任何内容。在这种情况下，任何包含文字的三元组都必须为false。因此，任何三元组，也就是任何图，如果包含一个 [ill-typed（错误类型）](https://www.w3.org/TR/rdf11-mt/#dfn-ill-typed)的文字。都将是 [D-unsatisfiable（D-不满足）](https://www.w3.org/TR/rdf11-mt/#dfn-d-unsatisfiable)的，即在每次D-interpretation中均为假。这仅适用于D中具有可识别数据类型IRIs的文字，具有未识别类型IRI的文字不是 [ill-typed（错误类型）](https://www.w3.org/TR/rdf11-mt/#dfn-ill-typed)，也不会产生 [D-unsatisfiable（D-不满足）](https://www.w3.org/TR/rdf11-mt/#dfn-d-unsatisfiable)图。

文字的特殊数据类型[`rdf:langString`](http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string)没有 [ill-typed（错误类型）](https://www.w3.org/TR/rdf11-mt/#dfn-ill-typed)。任何具有这种类型的语法合法文字都将在每个D解释中表示一个值，其中D包含`rdf:langString`。文字的[`xsd:string`](http://www.w3.org/TR/xmlschema11-2/#string)数据类型的唯一错误类型是那些包含与[ [XML10](https://www.w3.org/TR/rdf11-mt/#bib-XML10) ]中的 [Char production](http://www.w3.org/TR/xml11/#NT-Char)不匹配的Unicode码位的文字。此类字符串不能以XML兼容的表面语法编写。

> **Change Note"
>
> 在2004 RDF 1.0规范中，要求使用错误类型的文字来表示IR中的值，并且仅通过使用RDFS语义才能识别[D不满意](https://www.w3.org/TR/rdf11-mt/#dfn-d-unsatisfiable)。

### 7.2 数据类型蕴涵

一个图**D-satisfiable（D-满足）**或者**satisfiable recognizing D（D认知满足）**的含义是：在一些D-interpretation中，图的值为真。图S**(simply) D-entails（简单D-蕴含）**或 **entails recognizing D（D认知蕴含）**图G的条件是：对于每一个满足图S的D-interpretation同时也要D-satisfiable（D-满足）图G。

与[Simple Interpretations（简单解释）](https://www.w3.org/TR/rdf11-mt/#dfn-simple-interpretation)的情况不同，图可能没有令人满意的D-interpretations（D-解释），即是**D-unsatisfiable（D-不满足）**。RDF处理器*may(可以)*将无法满足的图形视为信号发出错误状态，但这不是必需的。

一个 [D-unsatisfiable（D-不满足）](https://www.w3.org/TR/rdf11-mt/#dfn-d-unsatisfiable)的图形D-entails（D-蕴含）任意图形。

>**Note**
>
>直接翻译：自上古以来，不满意的陈述包含任何其他陈述的事实已为人所知。这就是所谓的*quodlibet*原理。不应将其解释为意味着有必要甚至允许从不满意的图表中得出任何结论。
>
>人话：一个无法满足的陈述必然包含其他陈述这一事实自古以来就为人所知。这就是所谓的“即兴表演原则”。它不应该被解释为从一个不能令人满意的图中实际得出任何结论都是对的。

在所有的这种语言中，“D”被用作一个参数来表示一些数据类型IRIs，不同的D集将产生不同的可满足性和蕴涵性概念。我们识别的数据类型越多，蕴涵的意义就越强。所以如果D ⊂ E，S E-entails G，那么一定会有S D-entail G，简单的蕴涵是{}-蕴涵（空-蕴含），所以如果S D-entails G。那么S (simply) entails G。

#### 7.2.1 数据类型包含模式（信息性）

*本节是非规范性的。*

与[ simple entailment(简单蕴含)](https://www.w3.org/TR/rdf11-mt/#dfn-entail)不同，不可能给出一个单一语法标准来检测所有D-entailments（D-蕴含），这是由于[识别](https://www.w3.org/TR/rdf11-mt/#dfn-recognize)数据类型的[lexical-to-value mapping（词法到值映射）](https://www.w3.org/TR/rdf11-mt/#dfn-lexical-to-value-mapping)的特殊属性所导致的。

例如，如果D包含`xsd:decimal`则

```
ex:a ex:p "25.0"^^xsd:decimal .
```

D-entails（D-蕴含）

```
ex:a ex:p "25"^^xsd:decimal .
```

通常，任意一个包含被[recognize（识别）](https://www.w3.org/TR/rdf11-mt/#dfn-recognize)数据类型IRI的文字的三元组D-entails（D-蕴含）另一个文字（三元组）的含义是：当文字的语法字符串映射到数据类型的[lexical-to-value mapping（词法到值映射）](https://www.w3.org/TR/rdf11-mt/#dfn-lexical-to-value-mapping)得到的值相同。如果D中的两种不同的数据类型将词法字符串映射到一个公共值，那么包含一种数据类型的文字的三元组可能 D-entail（D-蕴含）另一种不同数据类型的文字的三元组。例如，`"25"^^xsd:integer`和`"25.0"^^xsd:decimal`具有相同的值，因此当D包含`xsd:integer`时，上面的例子也D-entails（D-蕴含）

```
ex:a ex:p "25"^^xsd:integer .
```

（有一个W3C的笔记[ [SWBP-XSCH-DATATYPES](https://www.w3.org/TR/rdf11-mt/#bib-SWBP-XSCH-DATATYPES) ]包含对文字值的长篇幅的[讨论](http://www.w3.org/TR/swbp-xsch-datatypes/#sec-values)。）

[ill-typed（错误类型）](https://www.w3.org/TR/rdf11-mt/#dfn-ill-typed)文字是使图形（简单） [D-unsatisfiable（D-不满足）](https://www.w3.org/TR/rdf11-mt/#dfn-d-unsatisfiable)的唯一方法，但是当数据类型与稍后定义的RDFS词汇表结合使用时，数据类型会引起多种其他无法满足的关系图。

## 8. RDF解释

RDF解释对`xsd:string`带有名称空间前缀的无限IRI集合和部分IRI施加了额外的语义条件`rdf:`。

| RDF词汇                                                      |
| ------------------------------------------------------------ |
| `（rdf:type rdf:subject rdf:predicate rdf:object rdf:first rdf:rest rdf:value rdf:nil rdf:List rdf:langString rdf:Property rdf:_1 rdf:_2 ...` |

**RDF interpretation recognizing D（RDF解释）**是一个[D-interpretations（D解释）](https://www.w3.org/TR/rdf11-mt/#dfn-d-interpretation)I，其中D包括`rdf:langString`和 `xsd:string`，并且满足：

| x在IP中当且仅当<x，I(`rdf:Property`)>在IEXT(I(`rdf:type`))中 |
| ------------------------------------------------------------ |
| 对于D中的每个IRI aaa，当且仅当x在I(aaa)的值空间中时，<x，I(aaa)>在IEXT(I(`rdf:type`))中 |

并满足以下无限集中的每个三元组：

```
rdf:type rdf:type rdf:Property .
rdf:subject rdf:type rdf:Property .
rdf:predicate rdf:type rdf:Property .
rdf:object rdf:type rdf:Property .
rdf:first rdf:type rdf:Property .
rdf:rest rdf:type rdf:Property .
rdf:value rdf:type rdf:Property .
rdf:nil rdf:type rdf:List .
rdf:_1 rdf:type rdf:Property .
rdf:_2 rdf:type rdf:Property ....
```

RDF对其余的RDF词汇表没有任何特殊的规范意义。 [附录D](https://www.w3.org/TR/rdf11-mt/#whatnot)描述了某些词汇的预期用途。

数据类型的IRI[`rdf:langString`](http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string)和[`xsd:string`](http://www.w3.org/TR/xmlschema11-2/#string)*must(必须)*被RDF interpretation（RDF 解释） [recognize（识别）](https://www.w3.org/TR/rdf11-mt/#dfn-recognize) 。

其他两个数据类型[`rdf:XMLLiteral`](http://www.w3.org/TR/rdf11-concepts/#section-XMLLiteral)和[`rdf:HTML`](http://www.w3.org/TR/rdf11-concepts/#section-html)定义在[RDF11-CONCEPTS](https://www.w3.org/TR/rdf11-mt/#bib-RDF11-CONCEPTS) 中。RDF-D interpretations（RDF-D解释）*may(可能)*无法[识别](https://www.w3.org/TR/rdf11-mt/#dfn-recognize)这些数据类型。

### 8.1 RDF需求

图S**RDF entail（RDF 蕴含）**图E**recognizing D（认知D）**的条件是：当每一个[RDF interpretation recognizing D（RDF 解释）](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-interpretation)满足图S时也满足图E，当D 只含有{`rdf:langString``xsd:string`}时我们可以说图S的**RDF entails（RDF 蕴含）**图E。图E是**RDF unsatisfiable (recognizing D){RDF-不满足（在认知D下）}**的条件是：图E没有合适的（满足的） [RDF interpretation](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-interpretation) (recognizing D){RDF 解释（在在认知D下）}。 

前面描述的简单包含的属性并不都适用于 [RDF entailment（RDF 蕴含）](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-entail)。例如，所有RDF公理在每个[RDF interpretation（RDF 解释）](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-interpretation)中都是正确的，空图所 [RDF entailed（RDF 蕴含）](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-entail) 的RDF公理也是如此，这与RDF蕴含的 [interpolation（差值）](https://www.w3.org/TR/rdf11-mt/#dfn-interpolation) 相矛盾。

#### 8.1.1 RDF包含模式（信息性）

*本节是非规范性的。*

上表中的最后一个语义条件给出了被[识别](https://www.w3.org/TR/rdf11-mt/#dfn-recognize)的数据类型IRIs的包含模式:

|       | **if S contains**                             | **then S RDF entails, recognizing D**           |
| ----- | --------------------------------------------- | ----------------------------------------------- |
| rdfD1 | xxx aaa `"`sss `"^^`ddd `.` <br/>for ddd in D | xxx aaa _：nnn `.`<br/> _：nnn `rdf:type`ddd`.` |

请注意，即使文字的数据类型[ill-typed（错误类型）](https://www.w3.org/TR/rdf11-mt/#dfn-ill-typed)，这也是有效的，因为一个无法满足的图蕴含任何三元组。

例如，

```
ex:a ex:p "123"^^xsd:integer .
```

RDF 需要识别{ `xsd:integer`}

```
ex:a ex:p _:x .
_:x rdf:type xsd:integer .
```

来识别{ `xsd:integer`}。

此外，第一个RDF语义条件证明了以下蕴含模式的合理性：

|       | **if S contains** | **then S RDF entails, recognizing D** |
| ----- | ----------------- | ------------------------------------- |
| rdfD2 | xxx aaa yyy `.`   | aaa `rdf:type rdf:Property .`         |

因此，上面的示例RDF

```
ex:p rdf:type rdf:Property .
```

来识别{ `xsd:integer`}。

某些数据类型支持特有的包含模式，而其他数据类型则不适用。例如，

```
ex:a ex:p "true"^^xsd:boolean .
ex:a ex:p "false"^^xsd:boolean .
ex:v rdf:type xsd:boolean .
```

RDF 需要

```
ex:a ex:p ex:v .
```

来识别{ `xsd:boolean`}。

此外，值空间上的语义条件可能产生其他不可满足的图。例如，当D包含`xsd:integer`和`xsd:boolean`时，则以下是[RDF unsatisfiable recognition D（）](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-unsatisfiable):

另外，值空间上的语义条件可能会产生其他无法满足的图。例如，当D包含，则以下是[RDF无法](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-unsatisfiable)识别D：

```
_:x rdf:type xsd:boolean .
_:x rdf:type xsd:integer .
```

## 9. RDFS解释

RDF Schema [ [RDF11-SCHEMA](https://www.w3.org/TR/rdf11-mt/#bib-RDF11-SCHEMA) ]将RDF扩展到具有更复杂语义约束的更大词汇表：

| RDFS词汇                                                     |
| ------------------------------------------------------------ |
| `rdfs:domain rdfs:range rdfs:Resource rdfs:Literal rdfs:Datatype rdfs:Class rdfs:subClassOf rdfs:subPropertyOf rdfs:member rdfs:Container rdfs:ContainerMembershipProperty rdfs:comment rdfs:seeAlso rdfs:isDefinedBy rdfs:label` |

（`rdfs:comment`，` rdfs:seeAlso`，`rdfs:isDefinedBy` 和`rdfs:label`都被包括在里面，因为它适用于他们使用一些约束可以用`rdfs:domain`，` rdfs:range` 以及`rdfs:subPropertyOf`来声明。除此之外，形式语义不限制它们的含义。）

用新的语义结构——**类（class）**来表示RDFS语义是很方便的，类（class）表示空间中一组事物的资源，这些事物都具有该类作为它们的`rdf:type`属性的值 。[Classes](https://www.w3.org/TR/rdf11-mt/#dfn-class)被定义为`rdfs:Class`的事物，一个解释中所有类的集合将称为IC。语义条件是通过从IC到IR子集的映射ICEXT（对于I中的*Class Extension*扩展）来表示的。

一个类的扩展名可能为空。两个不同的类可以具有相同的类扩展名。`rdfs:Class`的类扩展包含class `rdfs:Class`。

一个**RDFS interpretation (recognizing D){RDFS 解释（认知D）}**是 [RDF interpretation (recognizing D){RDF解释（认知D）}](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-interpretation) I，其满足下表中的语义的条件下，和在RDFS公理三元组的后续表中的所有的三元组。

| ICEXT(y)定义为{x：<x，y>在IEXT(I(`rdf:type`))}<br/>IC定义为ICEXT(I(`rdfs:Class`))<br/>LV定义为ICEXT(I（`rdfs:Literal`))<br/>ICEXT(I（`rdfs:Resource`))=IR<br/>ICEXT(I（`rdf:langString`))是集合{I(E)：E是语言标记的字符串}<br/>对于D中每隔一个IRI aaa，ICEXT(I(aaa))是I(aaa)的值空间<br/>对于D中的每个IRI aaa，I(aaa)在ICEXT(I（`rdfs:Datatype`))中 |
| ------------------------------------------------------------ |
| 如果<x，y>在IEXT（I（`rdfs:domain`））中，而<u，v>在IEXT（x）中，则u在ICEXT（y）中 |
| 如果<x，y>在IEXT（I（`rdfs:range`））中，而<u，v>在IEXT（x）中，则v在ICEXT（y）中 |
| IEXT（I（`rdfs:subPropertyOf`））对IP具有传递性和自反性      |
| 如果<x，y>在IEXT（I（`rdfs:subPropertyOf`））中，则x和y在IP中，而IEXT（x）是IEXT（y）的子集 |
| 如果x在IC中，则<x，I（`rdfs:Resource`）>在IEXT（I（`rdfs:subClassOf`））中 |
| IEXT（I（`rdfs:subClassOf`））在IC上具有传递性和自反性       |
| 如果<x，y>在IEXT（I（`rdfs:subClassOf`））中，则x和y在IC中，而ICEXT（x）是ICEXT（y）的子集 |
| 如果x在ICEXT（I（`rdfs:ContainerMembershipProperty`））中，则：<br/> <x，I（`rdfs:member`）>在IEXT（I（`rdfs:subPropertyOf`））中 |
| 如果x在ICEXT（I（`rdfs:Datatype`））中，则<x，I（`rdfs:Literal`）>在IEXT（I（`rdfs:subClassOf`））中 |

**RDFS公理的三元组。**

```
rdf:type rdfs:domain rdfs:Resource .
rdfs:domain rdfs:domain rdf:Property .
rdfs:range rdfs:domain rdf:Property .
rdfs:subPropertyOf rdfs:domain rdf:Property .
rdfs:subClassOf rdfs:domain rdfs:Class .
rdf:subject rdfs:domain rdf:Statement .
rdf:predicate rdfs:domain rdf:Statement .
rdf:object rdfs:domain rdf:Statement .
rdfs:member rdfs:domain rdfs:Resource .
rdf:first rdfs:domain rdf:List .
rdf:rest rdfs:domain rdf:List .
rdfs:seeAlso rdfs:domain rdfs:Resource .
rdfs:isDefinedBy rdfs:domain rdfs:Resource .
rdfs:comment rdfs:domain rdfs:Resource .
rdfs:label rdfs:domain rdfs:Resource .
rdf:value rdfs:domain rdfs:Resource .
rdf:type rdfs:range rdfs:Class .
rdfs:domain rdfs:range rdfs:Class .
rdfs:range rdfs:range rdfs:Class .
rdfs:subPropertyOf rdfs:range rdf:Property .
rdfs:subClassOf rdfs:range rdfs:Class .
rdf:subject rdfs:range rdfs:Resource .
rdf:predicate rdfs:range rdfs:Resource .
rdf:object rdfs:range rdfs:Resource .
rdfs:member rdfs:range rdfs:Resource .
rdf:first rdfs:range rdfs:Resource .
rdf:rest rdfs:range rdf:List .
rdfs:seeAlso rdfs:range rdfs:Resource .
rdfs:isDefinedBy rdfs:range rdfs:Resource .
rdfs:comment rdfs:range rdfs:Literal .
rdfs:label rdfs:range rdfs:Literal .
rdf:value rdfs:range rdfs:Resource .
rdf:Alt rdfs:subClassOf rdfs:Container .
rdf:Bag rdfs:subClassOf rdfs:Container .
rdf:Seq rdfs:subClassOf rdfs:Container .
rdfs:ContainerMembershipProperty rdfs:subClassOf rdf:Property .
rdfs:isDefinedBy rdfs:subPropertyOf rdfs:seeAlso .
rdfs:Datatype rdfs:subClassOf rdfs:Class .
rdf:_1 rdf:type rdfs:ContainerMembershipProperty .
rdf:_1 rdfs:domain rdfs:Resource .
rdf:_1 rdfs:range rdfs:Resource .
rdf:_2 rdf:type rdfs:ContainerMembershipProperty .
rdf:_2 rdfs:domain rdfs:Resource .
rdf:_2 rdfs:range rdfs:Resource . 
```



> **Change Note**
>
> 在2004 RDF 1.0语义中，LV被定义为简单解释结构的一部分，此处给出的定义是一个约束。

由于I是 [RDF interpretation（RDF解释）](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-interpretation)，因此第一个条件可以推得IP = ICEXT（I（`rdf:Property`））。

 [RDF interpretations（RDF解释）](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-interpretation)的语义条件以及ICEXT上的RDFS条件，意味着可以将每个已[recognize（识别）](https://www.w3.org/TR/rdf11-mt/#dfn-recognize)的数据类型都视为一个扩展名为该数据类型的值空间的类，并且每个具有该数据类型的文字要么没有引用，要么引用该类中的值。

使用RDFS语义时，所有可[recognize（识别）](https://www.w3.org/TR/rdf11-mt/#dfn-recognize)的数据类型IRI的引用都可以视为在[class（类）](https://www.w3.org/TR/rdf11-mt/#dfn-class) `rdfs:Datatype`中。

上面列出的公理和条件具有一定的冗余性。例如，除了一个RDF公理三元组之外，所有的RDF公理三元组都可以从RDFS公理三元组和ICEXT、` rdfs:domain`和`rdfs:range`的语义条件派生出来。

在所有RDFS解释中必须为真的其他三元组包括以下内容。这不是一个完整的集合。

**一些rdfs-有效三元组。**

```
rdfs:Resource rdf:type rdfs:Class .
rdfs:Class rdf:type rdfs:Class .
rdfs:Literal rdf:type rdfs:Class .
rdf:XMLLiteral rdf:type rdfs:Class .
rdf:HTML rdf:type rdfs:Class .
rdfs:Datatype rdf:type rdfs:Class .
rdf:Seq rdf:type rdfs:Class .
rdf:Bag rdf:type rdfs:Class .
rdf:Alt rdf:type rdfs:Class .
rdfs:Container rdf:type rdfs:Class .
rdf:List rdf:type rdfs:Class .
rdfs:ContainerMembershipProperty rdf:type rdfs:Class .
rdf:Property rdf:type rdfs:Class .
rdf:Statement rdf:type rdfs:Class .
rdfs:domain rdf:type rdf:Property .
rdfs:range rdf:type rdf:Property .
dfs:subPropertyOf rdf:type rdf:Property .
rdfs:subClassOf rdf:type rdf:Property .
rdfs:member rdf:type rdf:Property .
rdfs:seeAlso rdf:type rdf:Property .
rdfs:isDefinedBy rdf:type rdf:Property .
rdfs:comment rdf:type rdf:Property .
rdfs:label rdf:type rdf:Property .
```

RDFS不会将空间划分为不相关联的类，属性和个人类别。空间中的任何事物都可以用作类或属性，或两者兼有，同时保留其作为个体的状态（可能在类中并具有属性）。因此，RDFS允许包含其他类，属性类，类的属性等的类。如上面的公理三元组所示，它还允许包含其自身的类和适用于其自身的属性。类的属性不一定是其成员的属性，反之亦然。

### 9.1关于rdfs的说明：文字（资料性）

*本节是非规范性的。*

`rdfs:Literal`类不是文字的类别，而是文字值的类别，它也可以被IRIs引用。例如，LV不包含文字 `"foodle"^^xsd:string`，但确实包含字符串“ foodle”。

如下形式的三元组

```
ex:a rdf:type rdfs:Literal .
```

即使其主体是IRI而不是文字也一致。它说IRI`ex:a`指的是文字值，因为文字值是空间中的事物，所以这很有可能。出于相同的原因，空白节点可以覆盖文字值。

### 9.2 RDFS要求

图S**RDFS entail（RDFS 蕴含）**图E**recognizing D（认知D）**的条件是：当每一个 [RDFS interpretation recognizing D（RDFs 解释）](https://www.w3.org/TR/rdf11-mt/#dfn-rdfs-interpretation)满足图S时也满足图E，

当满足S的每个[RDFS](https://www.w3.org/TR/rdf11-mt/#dfn-rdfs-interpretation)识别D的满足也满足E时，S RDFS要求E**识别D。**

由于每个[RDFS interpretation（RDFS解释）](https://www.w3.org/TR/rdf11-mt/#dfn-rdfs-interpretation)都是[RDF interpretation（RDF解释）](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-interpretation)，因此，如果S [RDFS entails（RDFS 蕴含）](https://www.w3.org/TR/rdf11-mt/#dfn-rdfs-entails)E，则S也是[[RDF entails（RDF蕴含）](https://www.w3.org/TR/rdf11-mt/#dfn-rdf-entail)E。但是RDFS包含要比RDF包含要强。即使是空图，也具有大量的RDFS内容，而不是RDF内容，例如，形式如下的所有三元组

> aaa `rdf:type rdfs:Resource .`

其中aaa是IRI，在所有[RDFS interpretation（RDFS解释）](https://www.w3.org/TR/rdf11-mt/#dfn-rdfs-interpretation)中都是正确的。

#### 9.2.1 RDFS包含模式（信息性）

*本节是非规范性的。*

RDFS蕴含适用于以下所有模式，这些模式与RDFS语义条件紧密对应：

**RDFS蕴含模式**

|        | **If S contains:**                                           | **then S RDFS entails recognizing D:** |
| ------ | ------------------------------------------------------------ | -------------------------------------- |
| rdfs1  | D中的任何IRI aaa                                             | Aaa `rdf:type rdfs:Datatype .`         |
| rdfs2  | aaa `rdfs:domain`xxx `.` <br/>yyy aaa zzz`.`                 | yyy `rdf:type`xxx`.`                   |
| rdfs3  | aaa `rdfs:range`xxx `.`<br/> yyy aaa zzz`.`                  | zzz `rdf:type`xxx`.`                   |
| rdfs4a | xxx aaa yyy `.`                                              | xxx `rdf:type rdfs:Resource .`         |
| rdfs4b | xxx aaa yyy`.`                                               | Yyyy `rdf:type rdfs:Resource .`        |
| rdfs5  | xxx `rdfs:subPropertyOf`yyy `.` <br/>yyy `rdfs:subPropertyOf`zzz`.` | xxx `rdfs:subPropertyOf`zzz`.`         |
| rdfs6  | xxx `rdf:type rdf:Property .`                                | xxx `rdfs:subPropertyOf`xxx`.`         |
| rdfs7  | aaa `rdfs:subPropertyOf`bbb `.` <br/>xxx aaa yyy`.`          | xxx bbb yyy `.`                        |
| rdfs8  | xxx `rdf:type rdfs:Class .`                                  | xxx `rdfs:subClassOf rdfs:Resource .`  |
| rdfs9  | xxx `rdfs:subClassOf`yyy `.`<br/> zzz `rdf:type`xxx`.`       | zzz `rdf:type`yyy`.`                   |
| rdfs10 | xxx `rdf:type rdfs:Class .`                                  | xxx `rdfs:subClassOf`xxx`.`            |
| rdfs11 | xxx `rdfs:subClassOf`yyy `.`<br/> yyy `rdfs:subClassOf`zzz`.` | xxx `rdfs:subClassOf`zzz`.`            |
| rdfs12 | xxx `rdf:type rdfs:ContainerMembershipProperty .`            | xxx `rdfs:subPropertyOf rdfs:member .` |
| rdfs13 | xxx `rdf:type rdfs:Datatype .`                               | xxx `rdfs:subClassOf rdfs:Literal .`   |

RDFS提供了几种**unsatisfiable recognizing D**的新方法。例如，下图是RDFS无法识别{ `xsd:integer`，`xsd:boolean`}：

```
ex:p rdfs:domain xsd:boolean .
ex:a rdf:type xsd:integer .
ex:a ex:p ex:c .
```

## 10. RDF数据集

[RDF数据集](http://www.w3.org/TR/rdf11-concepts/#section-dataset)在RDF概念[ [RDF11-CONCEPTS](https://www.w3.org/TR/rdf11-mt/#bib-RDF11-CONCEPTS) ]中定义，它将零个或多个已命名的RDF图与一个未命名的默认RDF图打包在一起。单个数据集中的图形可以共享空白节点。SPARQL [ [SPARQL11-QUERY](https://www.w3.org/TR/rdf11-mt/#bib-SPARQL11-QUERY) ]使用图名称IRI与图的关联，以允许针对特定图进行查询。

数据集中的图名可能指的不是与它们配对的图。这允许在数据集中使用引用其他类型的实体（例如人）的IRI来[identify（标识）](https://www.w3.org/TR/rdf11-mt/#dfn-identify)与由图名IRI[denote（表示）](https://www.w3.org/TR/rdf11-mt/#dfn-denote)的实体相关的信息图。

当一个图名在数据集的RDF三元组中使用时，它可能引用也可能不引用它所命名的图。在没有外部原因的情况下，语义并不要求，RDF引擎也不应该假定RDF三元组中使用的图名引用它们所命名的图。

RDF数据集*may(可以)*用来表达RDF内容。当以这种方式使用时，*should(应该)*将数据集理解为至少具有与其默认图相同的内容。但是请注意，用逻辑上等效的图替换数据集的默认图通常不会产生结构相似的数据集，因为它可能会破坏默认图与数据集中其他图之间的空白节点同时出现的关系，这可能是因为除了数据集中图形的语义之外，数据集中的其他原因也很重要。

其他[语义扩展](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)和[蕴含机制](https://www.w3.org/TR/rdf11-mt/#dfn-entailment-regime)*may（可能）*会对RDF数据集设置进一步的语义条件和限制，就像RDF图一样。例如，这样的扩展可以建立一个类似模态的解释结构，这样数据集之间的引用就需要在同名的图之间添加RDF图(根据需要添加空图)。

## 附录

## A.蕴含规则（资料性）

*本节是非规范性的。*

*（本节在[ [HORST04](https://www.w3.org/TR/rdf11-mt/#bib-HORST04) ] ， [ [HORST05](https://www.w3.org/TR/rdf11-mt/#bib-HORST05) ]的基础上更全面地描述的蕴含规则，有关技术细节和证明，请参考该相关文档。*）

上表中列出的RDF和RDFS蕴含模式可以视为从左到右的规则，这些规则将所蕴含的结论添加到图形中。通过以下操作序列，这些规则集可用于检查图S和E之间是否存在RDF（或RDFS）蕴含：

1.将所有RDF（或RDF和RDFS）公理三元组添加到S中，除了那些包含容器属性成员IRIs：`rdf:_1, rdf:_2, ...`的三元组。
2.对于E中出现的每个容器属性成员IRI，添加包含该IRI的RDF（或RDF和RDFS）公理三元组。
3.将RDF（或RDF和RDFS）推理模式作为规则，将每个结论添加到图形中，以穷竭；也就是说，直到它们不生成新的三元组。
4.确定E是否具有一个作为集合的子集的实例，即，扩大的集合是否简单蕴含E。

这个过程显然是正确的，因为如果它给出了一个肯定的结果，那么S确实使RDF (RDFS)蕴含E。但是，它并不完整：有些情况下S蕴含E的情况无法通过此过程检测到。示例包括：

|                                                              | RDF 蕴含                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `ex:a ex:p "string"^^xsd:string .`<br/>`ex:b ex:q "string"^^xsd:string .` | `ex:a ex:p _:b .`<br/>`ex:b ex:q _:b .`<br/>`_:b rdf:type xsd:string .` |
|                                                              | RDFS 蕴含                                                    |
| `ex:a rdfs:subPropertyOf _:b .`<br/>`_:b rdfs:domain ex:c .`<br/>`ex:d ex:a ex:e .` | `ex:d rdf:type ex:c .`                                       |

这两种情况都可以通过允许规则应用于RDF语法的泛化来解决，在这种语法中，文字可以出现在主语位置，空白节点可以出现在谓语位置。

考虑使用[广义RDF三元组，图形和数据集，](http://www.w3.org/TR/rdf11-concepts/#section-generalized-rdf)来代替RDF三元组，图形和数据集（扩展了[ [HORST04](https://www.w3.org/TR/rdf11-mt/#bib-HORST04) ]中使用的泛化，并严格遵循[ [OWL2-PROFILES](https://www.w3.org/TR/rdf11-mt/#bib-OWL2-PROFILES) ]中使用的术语）。本文档中描述的语义适用于一般性而无需更改，因此可以自由使用解释，可满足性和蕴含的概念。然后，我们可以用更简单，更直接的方式替换第一个RDF包含模式

|        | **if S contains**                             | then S RDF entails, recognizing D |
| ------ | --------------------------------------------- | --------------------------------- |
| GrdfD1 | xxx aaa `"`sss `"^^`ddd `.` <br/>for ddd in D | `"`sss `"^^`ddd `rdf:type`ddd`.`  |

它给出了蕴涵:

`ex:a ex:p "string"^^xsd:string .`

`ex:b ex:q "string"^^xsd:string .`

`"string"^^xsd:string rdf:type xsd:string .` 由[GrdfD1](https://www.w3.org/TR/rdf11-mt/#dfn-grdfd1).

这是上面所需结论的一个实例（广义RDF）。

第二个示例可以使用RDFS规则得出：

`ex:a rdfs:subPropertyOf _:b .`

`_:b rdfs:domain ex:c .`

`ex:d ex:a ex:e .`

`ex:d _:b ex:c .` 由[rdfs7](https://www.w3.org/TR/rdf11-mt/#dfn-rdfs7)

`ex:d rdf:type ex:c .`由[rdfs2](https://www.w3.org/TR/rdf11-mt/#dfn-rdfs2)

在将蕴含模式应用于广义RDF语法后得出最终结论也是一个合法RDF。

使用广义语法，这些规则对于RDF和RDFS都是完整的。确切的说表示:

令S和E为RDF图。将**S对E的广义RDF（RDFS）闭包**定义为通过以下过程获得的集合。

1.将不包含任何容器成员资格属性IRI的所有RDF（和RDFS）公理三元组添加到S中。
2.对于E中出现的每个容器成员资格IRI，添加包含该IRI的RDF（和RDFS）公理三元组。
3.如果在步骤2中未添加任何三元组，则添加包含`rdf:_1`的RDF（和RDFS）公理三元组。
4.应用规则[GrdfD1](https://www.w3.org/TR/rdf11-mt/#dfn-grdfd1)和[rdfD2](https://www.w3.org/TR/rdf11-mt/#dfn-rdfd2)（和规则[rdfs1到rdfs13](https://www.w3.org/TR/rdf11-mt/#dfn-rdfs13)），d = { `rdf:langString`，`xsd:string`），添加所有可能的方式到集合中，至耗尽。

然后我们得出完整性结果：

> 如果S与RDF（RDFS）保持一致，则S RDF 蕴含（RDFS 蕴含）E 的唯一条件是：而S对E的[广义RDF（RDFS）闭包](https://www.w3.org/TR/rdf11-mt/#dfn-generalized-rdf-rdfs-closure)简单的蕴含E。

闭包是有限的。生成过程是可决定的，具有多项式复杂度。检测简单蕴涵一般是np完备的，但当E不包含空节点时是低多项式阶的。

每个RDF(S)闭包，甚至从空图开始，都将包含所有RDF(S)重述式，可以使用原始图的词汇表加上RDF和RDFS词汇表来表示。在实践中，重新推导这些规则几乎没有什么用处，可以使用规则的子集来建立大多数实际感兴趣的蕴涵。

如果必须遵守合法的RDF语法，则可以使用规则[rdfD1](https://www.w3.org/TR/rdf11-mt/#dfn-rdfd1)来代替[GrdfD1](https://www.w3.org/TR/rdf11-mt/#dfn-grdfd1)，引入的空白节点可以用作后续派生中的文字的替代。然而，生成的规则集并不完整。

如前所述，检测更大的数据类型IRIs集合的数据类型需要注意特定数据类型的特殊属性。

## B.有限的解释（资料性的）

*本节是非规范性的。*

为了使说明简单，对RDF语义的措辞要求要求解释的范围大于绝对必要的范围。例如，解释所有IRI词汇需要所有解释，并且D所包含的所有D解释的宇宙都 `xsd:string`必须包含所有可能的字符串，因此是无限的。本附录未经证实地概述了如何使用较小的语义结构重述语义，而又不更改任何内容。

基本上，仅需要一种解释结构来解释实际在考虑其含义的图中实际使用的[名称](https://www.w3.org/TR/rdf11-mt/#dfn-name)s，并考虑其Universe最多与图中的名称和空白节点数量一样大的解释。更正式地，我们可以定义一个预先解释过[的词汇](https://www.w3.org/TR/rdf11-mt/#dfn-vocabulary)V至是结构我类似[简单的解释](https://www.w3.org/TR/rdf11-mt/#dfn-simple-interpretation)，但只有从V到它的宇宙红外线的映射。然后，在确定G是否包含E时，仅考虑对[名称](https://www.w3.org/TR/rdf11-mt/#dfn-name)的有限词汇进行预解释此类预解释的范围可以限于基数N + B + 1，其中N是词汇量，B是图中空白节点的数量。任何这样的预解释都可以扩展为[简单解释](https://www.w3.org/TR/rdf11-mt/#dfn-simple-interpretation)s，所有这些都将为G或E中的任何三元组提供相同的真值。然后，可以针对这些有限的预解释定义可满足性，蕴含度等，并且显示与规范正文中定义的思想相同。

在考虑D蕴涵时，可以通过削弱数据类型文字的语义条件来使预解释保持有限，从而使IR仅包含实际出现在G或E中的文字的文字值，并且宇宙的大小限制为（N + B）×（D + 1），其中D是已识别数据类型的数量。（可能会有更严格的界限。）对于RDF而言，只有RDF词汇表的有限部分（包括那些实际在图中出现的容器成员资格属性）才需要解释，第二个RDF语义条件被弱化以仅应用于值这是实际出现在词汇表中的文字值。对于RDFS解释，同样，只需要解释在所考虑的图中实际出现的无限容器成员属性词汇表的有限部分。在所有这些情况下，可以将图形词汇的预解释扩展为对适当类型的完整解释，而无需更改图形中任何三元组的真值。

如果认为*有限模型属性*很重要，则可以按照预解释的方式描述整个语义，产生相同的含义，并允许在有限的结构中解释有限的RDF图。

## C.一些结果的证明（资料性）

*本节是非规范性的。*

> 该[空图](https://www.w3.org/TR/rdf11-mt/#dfn-empty-graph)简单地由任何图形entailed，并不仅仅意味着任何图形除了本身。

空图在所有简单的解释中都是正确的，因此任何图都需要。如果G包含一个三元组<ab c>，那么任何具有IEXT（I（b））= {}的简单解释I都会使G变为假。因此，空图不会包含G. QED。

> 一个图仅包含其所有子图。

如果我满足G，则它满足G中的每个三元组，因此满足G.QED中任何子集的每个三元组。

> 图仅由其任何[实例](https://www.w3.org/TR/rdf11-mt/#dfn-instance)s所包含。

假设H是具有实例化映射M的G的实例，并且我满足H。然后I + A满足G，所以我满足G. QED。

> 每个图都是可以满足的。

考虑对于任何IRI aaa而言，对于Universe {x}，IEXT（x）= <x，x>和I（aaa）= x的简单解释。这种解释满足每个RDF图。QED。

> 当且仅当G的子图是E的实例时，G才简单地包含图E。

如果G的子图E'是E的一个实例，则G包含E'，E包含E，因此G包含E。现在假定G包含E，并考虑对G的[Herbrand解释](http://en.wikipedia.org/wiki/Herbrand_interpretation)I，其定义如下。IR包含[名称](https://www.w3.org/TR/rdf11-mt/#dfn-name)s和图中出现的空白节点，每个[名称](https://www.w3.org/TR/rdf11-mt/#dfn-name)n的I（n）= n；当三元组<an b>在图中时，n在IP中，而IEXT（n）中在<a，b>中。（对于图中未出现的IRI，请在IR中随机分配它们的值。）我满足E中的每个三元组<sp o>；也就是说，对于从E的空白节点到G的词汇表的一些映射A，三元组[[I + A]（s）I（p）[I + A]（o）>出现在G中。但这是在实例映射A下的<sp o>实例；因此，E的实例是G. QED的子图。

> 如果E是瘦的，并且E'是E的适当实例，那么E并不仅仅意味着E'。

假设E包含E'，则E的子图是E'的实例，这是E的适当实例；因此，E的一个子图是E的适当实例，因此E不是精益的。QED。

> 如果E包含在S中不出现的IRI，则S不会简单地包含E。

如果S包含E，则S的子图是E的实例，因此E中的每个IRI必须出现在该子图中，因此必须出现在S. QED中。

> 对于任何图H，如果sk（G）仅包含H，则存在图H'，使得G包含H'，并且H = sk（H'）。

skolemization映射sk为每个空白节点替换一个唯一的新IRI，因此它是1：1，因此具有逆。将ks定义为逆映射，将其替换的空白节点替换每个skolem IRI。由于sk（G）包含H，因此sk（G）的子图是H的一个实例，对于在H的空白节点上映射A的某些实例，说A（H）。则ks（A（H））是H的子图。 G; 和ks（A（H））= A（ks（H）），因为A和ks的域是不相交的。因此ks（H）有一个实例，它是G的一个子图，因此由G引起；和H = sk（ks（H））。QED。

> 对于不包含引入sk（G）的任何“新” IRI的任何图H，当且仅当G仅包含H时，sk（G）仅包含H。

使用先前证明中的术语：如果H不包含任何斯科雷IRI，则H = ks（H）。因此，如果sk（G）包含H，则G包含ks（H）= H; 如果G包含H，则sk（G）包含G包含H，因此sk（G）包含H。

## D. RDF的修订，容器和馆藏（资料性）

*本节是非规范性的。*

RDF语义条件并未对要用于描述容器和有界集合的大部分RDF词汇表的意义施加形式上的约束，也没有对旨在使RDF图描述RDF三元组的说明性词汇表产生正式的约束。本附录简要回顾了该词汇表的预期含义。

从形式语义上省略这些条件是一项设计决策，以适应现有RDF使用情况的变化，并使其更易于实施检查形式RDF需求的过程。例如，实现可以决定使用特殊的过程技术来实现RDF集合词汇。

### D.1修正

| **RDF修正词汇**                                      |
| ---------------------------------------------------- |
| `rdf:Statement rdf:subject rdf:predicate rdf:object` |

该词汇表的预期含义是允许RDF图充当描述其他RDF三元组的元数据。

考虑一个包含单个三元组的示例图：

```
ex:a ex:b ex:c .
```

并假设使用IRI`ex:graph1`来[识别](https://www.w3.org/TR/rdf11-mt/#dfn-identify)该图。究竟如何实现此标识在RDF模型的外部，但可能是通过IRI解析为描述该图的具体语法文档，或者是通过IRI作为数据集中命名图的关联名称。假设可以使用IRI来指代三元组，那么通过分类词汇可以使我们在另一张图中描述第一个图：

```
ex:graph1 rdf:type rdf:Statement .ex:graph1 rdf:subject ex:a .ex:graph1 rdf:predicate ex:b .ex:graph1 rdf:object ex:c .
```

第二张图在第一张图中称为三元组的形式化。

修正不是引号的形式。确切地说，该描述描述了三元组的令牌与该三元组所引用的资源之间的关系。该`rdf:subject`属性的值不是主题IRI本身，而是它所表示的内容，并且对于`rdf:predicate`和而言类似`rdf:object`。例如，如果的引用者`ex:a`是珠穆朗玛峰，则经过修改的三元组的主题也就是山峰，而不是引用它的IRI。

[物化](https://www.w3.org/TR/rdf11-mt/#dfn-reification)S可与一个空节点作为主体被写入，或与IRI受试者不[识别](https://www.w3.org/TR/rdf11-mt/#dfn-identify)一个三重的任何具体实现，在这两种情况下，它们简单地断言的存在说明三倍。

一个的主题[具体化](https://www.w3.org/TR/rdf11-mt/#dfn-reification)是指一种具体实现的RDF三联，如在一个表面语法的文件，而不是一个三重视为抽象对象。这支持了将诸如组成日期或出处信息之类的属性应用于经过修饰的三元组的用例，这些用例仅在被认为是指三元组的特定实例或标记时才有意义。

三元组的[形式化](https://www.w3.org/TR/rdf11-mt/#dfn-reification)不需要三元组，也不是它所必须的。该 [物化](https://www.w3.org/TR/rdf11-mt/#dfn-reification)只说三令牌存在，它是什么，而不是它是真实的，所以它并不意味着三联。另一方面，声明三元组并不能自动暗示在由该三元组描述的Universe中存在任何三元组标记。例如，三元组可能是描述动物的本体的一部分，这可以通过一种解释来满足，在该解释中，宇宙仅包含动物，因此对它的[具体化](https://www.w3.org/TR/rdf11-mt/#dfn-reification)是错误的。

由于在任何一个或多个RDF图中三元组和三元[化的](https://www.w3.org/TR/rdf11-mt/#dfn-reification)s之间的关系不必是一对一的，因此断言由某个[化](https://www.w3.org/TR/rdf11-mt/#dfn-reification)所描述的某个实体的属性不必意味着另一个实体具有相同的属性，即使它具有相同的组件。例如，

```
_:xxx rdf:type rdf:Statement ._:xxx rdf:subject ex:subject ._:xxx rdf:predicate ex:predicate ._:xxx rdf:object ex:object ._:yyy rdf:type rdf:Statement ._:yyy rdf:subject ex:subject ._:yyy rdf:predicate ex:predicate ._:yyy rdf:object ex:object ._:xxx ex:property ex:foo .
```

不需要

```
_:yyy ex:property ex:foo .
```

### D.2 RDF容器

| **RDF（S）容器词汇**                                         |
| ------------------------------------------------------------ |
| `rdf:Seq rdf:Bag rdf:Alt rdf:_1 rdf:_2 ... rdfs:member rdfs:Container rdfs:ContainerMembershipProperty` |

RDF提供用于描述三类容器的词汇。容器具有类型，可以通过使用一组固定的*容器成员资格属性*来枚举其成员。这些属性由整数索引，以提供一种区分成员的方法，但是这些索引不必一定被认为是定义容器本身的顺序。一些容器被认为是无序的。

所述[RDFS词汇](https://www.w3.org/TR/rdf11-mt/#dfn-rdfs-vocabulary)增加，其保持而不管位置的通用成员属性，以及包含所有的容器类和所有成员的属性。

人们应该将此词汇理解为*描述* 容器，而不是像通常由编程语言提供的那样作为构建容器的工具。实际的容器是语义领域中的实体，使用词汇表的RDF图仅提供有关这些实体的非常基本的信息，从而使RDF图能够表征容器的类型并提供有关容器成员的部分信息。由于RDF容器词汇如此有限，因此RDF形式语义不能正式认可与RDF容器有关的许多自然假设。这不应被视为意味着这些假设是错误的，而仅仅是RDF并不正式意味着它们必须是正确的。

容器词汇表上没有特殊的语义条件：RDF假定其容器具有的唯一结构是可以从使用该词汇表和一般RDF语义条件中推断出的结构。这相当于知道容器的类型，并部分枚举了容器中的物品。预期的使用方式是类型的事物`rdf:Bag` 被认为是无序的，但允许重复；类型的东西`rdf:Seq`被认为是有序的，类型的东西`rdf:Alt`被认为代表备选方案的集合，可能具有优先顺序。如果容器是有序类型，则容器中各项的顺序应由容器隶属关系属性的数字顺序指示，这些属性被假定为单值。但是，这些非正式条件并未反映在任何正式的RDF要求中。

RDF语义不支持`rdf:Bag`以不同顺序枚举无序元素可能引起的任何问题。例如，

```
_:xxx rdf:type rdf:Bag ._:xxx rdf:_1 ex:a ._:xxx rdf:_2 ex:b .
```

不需要

```
_:xxx rdf:_1 ex:b ._:xxx rdf:_2 ex:a .
```

（如果这个结论是[有效](https://www.w3.org/TR/rdf11-mt/#dfn-valid)，然后将它添加到原始曲线图的结果将是[继承权](https://www.w3.org/TR/rdf11-mt/#dfn-entail)由图形编辑，并且这将断言两个元件是在两个位置，这是以下事实的一个结果是RDF是一种纯粹的assertional语言。）

没有假定容器的属性适用于容器的任何元素，反之亦然。

没有正式的要求，这三个容器类是不相交的，因此例如可以断言某物既是an`rdf:Bag`又是an `rdf:Seq`。没有假设容器是无间隙的，因此例如

```
_:xxx rdf:type rdf:Seq._:xxx rdf:_1 ex:a ._:xxx rdf:_3 ex:c .
```

不需要

```
_:xxx rdf:_2 _:yyy .
```

RDF中无法断言容器仅包含固定数量的成员。这反映了一个事实，即向图添加三元组以声明任何容器的隶属关系属性始终是一致的。最后，没有内置的假设认为RDF容器只有有限的许多成员。

### D.3 RDF集合

| **RDF收集词汇**                       |
| ------------------------------------- |
| `rdf:List rdf:first rdf:rest rdf:nil` |

RDF提供了一个用头尾链接来描述集合的词汇，即“列表结构”。集合与容器的不同之处在于允许分支结构和具有显式终止符，从而允许应用程序确定集合中项目的确切集合。

至于集装箱，没有特殊的语义条件强加给这个词汇比的其他类型`rdf:nil`是`rdf:List`。它通常用于在使用空白节点描述容器以连接“格式正确”的项目序列的情况下使用，每个项目均由形式的两个三元组描述`_:c1 rdf:first aaa ._:c1 rdf:rest _:c2 .`

通过使用`rdf:nil`用作属性的值来指示最后一项`rdf:rest`。按照惯例，`rdf:nil` 可以将其视为空集合。任何这样的图形都等于断言该集合存在，并且由于可以通过检查来确定集合的成员，因此这通常足以使应用程序确定含义。除了图形中明确提到的那些集合（以及空集合）之外，语义不需要任何集合存在。例如，包含两个项目的集合的存在并不能自动保证也存在排列了项目的相似集合：`_:c1 rdf:first ex:aaa ._:c1 rdf:rest _:c2 ._:c2 rdf:first ex:bbb ._:c2 rdf:rest rdf:nil .`

不需要

```
_:c3 rdf:first ex:bbb ._:c3 rdf:rest _:c4 ._:c4 rdf:first ex:aaa ._:c4 rdf:rest rdf:nil .
```

同样，RDF在使用此词汇表时不施加“格式正确”的条件，因此可以编写RDF图来断言存在高度特殊的对象，例如具有分叉或非列表尾部的列表或多个头的列表：

```
_:666 rdf:first ex:aaa ._:666 rdf:first ex:bbb ._:666 rdf:rest ex:ccc ._:666 rdf:rest rdf:nil .
```

也有可能编写一组三元组，这些三元组由于未指定其`rdf:rest`属性值而未充分指定一个集合。

[语义扩展](https://www.w3.org/TR/rdf11-mt/#dfn-semantic-extension)可能会对该词汇的使用施加额外的语法良好格式限制，以排除此类图。它们可能排除对集合词汇的解释，这些解释违反了约定，即上述形式的三联项的“链接”集合的主题（以结尾的项`rdf:nil`表示）表示其成员是的表示的完全有序的序列。项的`rdf:first` 值，按`rdf:rest`从主题到跟踪属性的顺序`rdf:nil`。这允许包含其他序列的序列。

RDFS语义条件要求该`rdf:first`属性的任何主题以及该属性的任何主题或对象`rdf:rest`都应为`rdf:type rdf:List`。